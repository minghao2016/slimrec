---
title: "Vignette: slimrec"
author: "Srikanth KS"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette_slimrec}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

This package implements [SLIM: Sparse Linear Methods for Top-N Recommender Systems](http://glaros.dtc.umn.edu/gkhome/node/774) by introduced by Xia Ning and George Karypis.

The method predicts ratings of a user for a given item as a linear   combination ratings of all other items provided by the user. The   coefficients for an item are determined elastic-net regression (both L1 and L2 regularization) over ratings matrix.

The optimization problem solves:
$$\min_{c_{j,.}} \left( \frac{1}{2} \|a_{j,.} - Ac_{j,.}\|^2_{2} +   \frac{\beta}{2} \|c_{j,.}\|^2_{2} + \gamma \|c_{j,.}\|_{1} \right)$$
subject to   $c_{j,j} = 0$ and optional non-negative constraint $c_{j,.} \ge 0$ where $a_{j,.}$ is the $j$ th column of the input ratings matrix and $c_{j,.}$ is the $j$ th column of the coefficient matrix (to be determined).

The method assumes that unknown rating values to be zero. Hence, it is primarily designed for implicit feedback mechanisms, but not restricted them. The main use of the ratings is to generate top-n lists of users and items.

# Implementation

The package provides three functions:

- `slim`: Function to compute ratings and coefficient matrix for the sparse ratings matrix using SLIM method.
- `tune_slim`: Function to arrive at an optimal value of alpha for slim.
- `top_rows` and `top_cols`: Functions to find row/column numbers corresponding the largest values in a particular column/row of a matrix. This is helpful to generate top-n users or items as recommendations.

The included datasets are:

- `ft_implicit`: sparse matrix with 1508 users and 2071 items. There are 35494 ratings ( sparsity = 0.0114 ). When rated, the ratings are always 1. When not rated, the ratings are 0.
- `ft_explicit`: Same as `ft_implicit`, but with ratings from  (0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0). When not rated, the ratings are 0.
- `ft_small`: This is left-top $100 \times 1000$ subset of `ft_imlicit`

# Basic Examples

Lets do some basic setup:

```{r}
# create a temporary directory
td <- file.path(tempdir(), "temp_vignette")
dir.create(td)
library("slimrec")
data(ft_implicit)
dim(ft_implicit)
# how sparse is `ft_implicit`
sum(ft_implicit != 0)/((dim(ft_implicit)[1])*(dim(ft_implicit)[2]))
```

## slim

The `slim` function is the primary workhorse. This expects a sparse matrix of ratings (users along rows and items along columns) and writes the predicted ratings matrix to disk onto a file-backed bigmatrix object. There are options to return the predicted ratings matrix as a matrix (in memory), cleanup disk-based bigmatrix objects, return coefficient matrix, compute RMSE for nonzero ratings and so on. It is advised not to provide the shrinkage parameter `lambda`. The underlying `glmnet::glmnet` function finds an optimal one. 

Since, each column of the coefficient matrix is computed independent of each other, using multiple cores might lead to significant speedup at the cost of higher memory utilization.

```{r}
temp <- slim(mat           = ft_implicit # input sparse ratings matrix
             , alpha       = 0.5         # 0 for ridge, 1 for lasso
             #, lambda                   # suggested not to set lambda
             #, nlambda                  # using default nlambda = 100
             , nonNegCoeff = TRUE        # better accuracy, lower interpretability
             , directory   = td          # dir where output matrices are stored
             , coeffMat    = TRUE        # helpful in 'predict'ing later
             , returnMat   = TRUE        # return matrices in memory
             , computeRMSE = TRUE        # RMSE over rated items
             , nproc       = 2L          # number of concurrent processes
             , progress    = TRUE        # show a progressbar
             , check       = TRUE        # do basic checks on input params
             , cleanup     = FALSE       # keep output matrices on disk
             )
str(temp)
```

The output ratings matrix would be comparatively denser.
```{r}
predMat <- temp[["ratingMat"]] != 0
sum(predMat)/((dim(predMat)[1])*(dim(predMat)[2]))
```

## top_rows/cols

Lets generate top-n recommendations based on the predicted ratings matrix.

```{r}
# recommend top 5 items for a user 10
top_cols(temp[["ratingMat"]]
         , row = 10
         , k   = 5
         )
# if you intend to avoid recommending 10, 215 and 3
top_cols(temp[["ratingMat"]]
         , row = 10
         , k   = 5
         , ignore = c(10, 215, 3)
         )
```

Analogously,

```{r}
# recommend top 5 users for item 100
top_rows(temp[["ratingMat"]]
         , col = 100
         , k   = 5
         )
```

## tune_slim

`tune_slim` assists in deciding on the *optimal* value of `alpha` via cross-validation. This uses `slim` function and keeps resultant coefficient matrix in memory. So, this might be suited only for a reasonably sized subset. Moreover, ability of `glmnet::glmnet` to figure out *optimal* `lambda` means that variation in `alpha` mostly leads to *small* changes in RMSE (over rated items).

```{r}
tune_slim(mat           = ft_small       # smallish 100 * 1000 matrix
          , alphaRange  = seq(0, 1, 0.3) # 0, 0.3, 0.6, 0.9
          , nonNegCoeff = TRUE           # better accuracy, lower interpretability
          , nfold       = 5              # 5-fold CV
          #, seed                        # set seed automatically
          , directory   = td             # objects are kept and cleaned up by end
          , nproc       = 2L             # number of concurrent processes
          , progress    = TRUE           # show a progressbar
          )
```

# Scalability

If you intend to use SLIM method for large matrices( around >= 1e7 ratings), this package might be slow enough to be practically useful even in parallel mode. You might want to look at [biglasso](https://cran.r-project.org/package=biglasso) and other implementations like JAVA based [librec](http://www.librec.net/).

```{r}
# delete the temporary vignette directory
unlink(td, recursive = TRUE)
```